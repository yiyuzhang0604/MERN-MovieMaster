{"ast":null,"code":"import Observable from 'zen-observable-ts';\nexport { default as Observable } from 'zen-observable-ts';\nimport { invariant, InvariantError } from 'ts-invariant';\nimport { __extends, __assign } from 'tslib';\nimport { getOperationName } from 'apollo-utilities';\nexport { getOperationName } from 'apollo-utilities';\n\nfunction validateOperation(operation) {\n  var OPERATION_FIELDS = ['query', 'operationName', 'variables', 'extensions', 'context'];\n\n  for (var _i = 0, _a = Object.keys(operation); _i < _a.length; _i++) {\n    var key = _a[_i];\n\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw process.env.NODE_ENV === \"production\" ? new InvariantError(2) : new InvariantError(\"illegal argument: \" + key);\n    }\n  }\n\n  return operation;\n}\n\nvar LinkError = function (_super) {\n  __extends(LinkError, _super);\n\n  function LinkError(message, link) {\n    var _this = _super.call(this, message) || this;\n\n    _this.link = link;\n    return _this;\n  }\n\n  return LinkError;\n}(Error);\n\nfunction isTerminating(link) {\n  return link.request.length <= 1;\n}\n\nfunction toPromise(observable) {\n  var completed = false;\n  return new Promise(function (resolve, reject) {\n    observable.subscribe({\n      next: function (data) {\n        if (completed) {\n          process.env.NODE_ENV === \"production\" || invariant.warn(\"Promise Wrapper does not support multiple results from Observable\");\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject\n    });\n  });\n}\n\nvar makePromise = toPromise;\n\nfunction fromPromise(promise) {\n  return new Observable(function (observer) {\n    promise.then(function (value) {\n      observer.next(value);\n      observer.complete();\n    }).catch(observer.error.bind(observer));\n  });\n}\n\nfunction fromError(errorValue) {\n  return new Observable(function (observer) {\n    observer.error(errorValue);\n  });\n}\n\nfunction transformOperation(operation) {\n  var transformedOperation = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query\n  };\n\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName = typeof transformedOperation.query !== 'string' ? getOperationName(transformedOperation.query) : '';\n  }\n\n  return transformedOperation;\n}\n\nfunction createOperation(starting, operation) {\n  var context = __assign({}, starting);\n\n  var setContext = function (next) {\n    if (typeof next === 'function') {\n      context = __assign({}, context, next(context));\n    } else {\n      context = __assign({}, context, next);\n    }\n  };\n\n  var getContext = function () {\n    return __assign({}, context);\n  };\n\n  Object.defineProperty(operation, 'setContext', {\n    enumerable: false,\n    value: setContext\n  });\n  Object.defineProperty(operation, 'getContext', {\n    enumerable: false,\n    value: getContext\n  });\n  Object.defineProperty(operation, 'toKey', {\n    enumerable: false,\n    value: function () {\n      return getKey(operation);\n    }\n  });\n  return operation;\n}\n\nfunction getKey(operation) {\n  var query = operation.query,\n      variables = operation.variables,\n      operationName = operation.operationName;\n  return JSON.stringify([operationName, query, variables]);\n}\n\nfunction passthrough(op, forward) {\n  return forward ? forward(op) : Observable.of();\n}\n\nfunction toLink(handler) {\n  return typeof handler === 'function' ? new ApolloLink(handler) : handler;\n}\n\nfunction empty() {\n  return new ApolloLink(function () {\n    return Observable.of();\n  });\n}\n\nfunction from(links) {\n  if (links.length === 0) return empty();\n  return links.map(toLink).reduce(function (x, y) {\n    return x.concat(y);\n  });\n}\n\nfunction split(test, left, right) {\n  var leftLink = toLink(left);\n  var rightLink = toLink(right || new ApolloLink(passthrough));\n\n  if (isTerminating(leftLink) && isTerminating(rightLink)) {\n    return new ApolloLink(function (operation) {\n      return test(operation) ? leftLink.request(operation) || Observable.of() : rightLink.request(operation) || Observable.of();\n    });\n  } else {\n    return new ApolloLink(function (operation, forward) {\n      return test(operation) ? leftLink.request(operation, forward) || Observable.of() : rightLink.request(operation, forward) || Observable.of();\n    });\n  }\n}\n\nvar concat = function (first, second) {\n  var firstLink = toLink(first);\n\n  if (isTerminating(firstLink)) {\n    process.env.NODE_ENV === \"production\" || invariant.warn(new LinkError(\"You are calling concat on a terminating link, which will have no effect\", firstLink));\n    return firstLink;\n  }\n\n  var nextLink = toLink(second);\n\n  if (isTerminating(nextLink)) {\n    return new ApolloLink(function (operation) {\n      return firstLink.request(operation, function (op) {\n        return nextLink.request(op) || Observable.of();\n      }) || Observable.of();\n    });\n  } else {\n    return new ApolloLink(function (operation, forward) {\n      return firstLink.request(operation, function (op) {\n        return nextLink.request(op, forward) || Observable.of();\n      }) || Observable.of();\n    });\n  }\n};\n\nvar ApolloLink = function () {\n  function ApolloLink(request) {\n    if (request) this.request = request;\n  }\n\n  ApolloLink.prototype.split = function (test, left, right) {\n    return this.concat(split(test, left, right || new ApolloLink(passthrough)));\n  };\n\n  ApolloLink.prototype.concat = function (next) {\n    return concat(this, next);\n  };\n\n  ApolloLink.prototype.request = function (operation, forward) {\n    throw process.env.NODE_ENV === \"production\" ? new InvariantError(1) : new InvariantError('request is not implemented');\n  };\n\n  ApolloLink.empty = empty;\n  ApolloLink.from = from;\n  ApolloLink.split = split;\n  ApolloLink.execute = execute;\n  return ApolloLink;\n}();\n\nfunction execute(link, operation) {\n  return link.request(createOperation(operation.context, transformOperation(validateOperation(operation)))) || Observable.of();\n}\n\nexport { ApolloLink, concat, createOperation, empty, execute, from, fromError, fromPromise, makePromise, split, toPromise };","map":{"version":3,"mappings":"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","names":["validateOperation","operation","OPERATION_FIELDS","keys","_i","key","indexOf","process","tslib_1.__extends","message","link","_super","_this","Error","isTerminating","request","length","toPromise","observable","completed","Promise","resolve","reject","subscribe","next","data","error","makePromise","fromPromise","promise","Observable","then","value","observer","complete","catch","bind","fromError","errorValue","transformOperation","transformedOperation","variables","extensions","operationName","query","getOperationName","createOperation","starting","context","setContext","getContext","Object","defineProperty","enumerable","getKey","JSON","stringify","passthrough","op","forward","of","toLink","handler","ApolloLink","empty","from","links","map","reduce","x","y","concat","split","test","left","right","leftLink","rightLink","first","second","firstLink","nextLink","execute"],"sources":["../src/linkUtils.ts","../src/link.ts"],"sourcesContent":["import Observable from 'zen-observable-ts';\n\nimport { GraphQLRequest, Operation } from './types';\nimport { ApolloLink } from './link';\n\nimport { getOperationName } from 'apollo-utilities';\nimport { invariant, InvariantError } from 'ts-invariant';\nexport { getOperationName };\n\nexport function validateOperation(operation: GraphQLRequest): GraphQLRequest {\n  const OPERATION_FIELDS = [\n    'query',\n    'operationName',\n    'variables',\n    'extensions',\n    'context',\n  ];\n  for (let key of Object.keys(operation)) {\n    if (OPERATION_FIELDS.indexOf(key) < 0) {\n      throw new InvariantError(`illegal argument: ${key}`);\n    }\n  }\n\n  return operation;\n}\n\nexport class LinkError extends Error {\n  public link: ApolloLink;\n  constructor(message?: string, link?: ApolloLink) {\n    super(message);\n    this.link = link;\n  }\n}\n\nexport function isTerminating(link: ApolloLink): boolean {\n  return link.request.length <= 1;\n}\n\nexport function toPromise<R>(observable: Observable<R>): Promise<R> {\n  let completed = false;\n  return new Promise<R>((resolve, reject) => {\n    observable.subscribe({\n      next: data => {\n        if (completed) {\n          invariant.warn(\n            `Promise Wrapper does not support multiple results from Observable`,\n          );\n        } else {\n          completed = true;\n          resolve(data);\n        }\n      },\n      error: reject,\n    });\n  });\n}\n\n// backwards compat\nexport const makePromise = toPromise;\n\nexport function fromPromise<T>(promise: Promise<T>): Observable<T> {\n  return new Observable<T>(observer => {\n    promise\n      .then((value: T) => {\n        observer.next(value);\n        observer.complete();\n      })\n      .catch(observer.error.bind(observer));\n  });\n}\n\nexport function fromError<T>(errorValue: any): Observable<T> {\n  return new Observable<T>(observer => {\n    observer.error(errorValue);\n  });\n}\n\nexport function transformOperation(operation: GraphQLRequest): GraphQLRequest {\n  const transformedOperation: GraphQLRequest = {\n    variables: operation.variables || {},\n    extensions: operation.extensions || {},\n    operationName: operation.operationName,\n    query: operation.query,\n  };\n\n  // best guess at an operation name\n  if (!transformedOperation.operationName) {\n    transformedOperation.operationName =\n      typeof transformedOperation.query !== 'string'\n        ? getOperationName(transformedOperation.query)\n        : '';\n  }\n\n  return transformedOperation as Operation;\n}\n\nexport function createOperation(\n  starting: any,\n  operation: GraphQLRequest,\n): Operation {\n  let context = { ...starting };\n  const setContext = next => {\n    if (typeof next === 'function') {\n      context = { ...context, ...next(context) };\n    } else {\n      context = { ...context, ...next };\n    }\n  };\n  const getContext = () => ({ ...context });\n\n  Object.defineProperty(operation, 'setContext', {\n    enumerable: false,\n    value: setContext,\n  });\n\n  Object.defineProperty(operation, 'getContext', {\n    enumerable: false,\n    value: getContext,\n  });\n\n  Object.defineProperty(operation, 'toKey', {\n    enumerable: false,\n    value: () => getKey(operation),\n  });\n\n  return operation as Operation;\n}\n\nexport function getKey(operation: GraphQLRequest) {\n  // XXX We're assuming here that query and variables will be serialized in\n  // the same order, which might not always be true.\n  const { query, variables, operationName } = operation;\n  return JSON.stringify([operationName, query, variables]);\n}\n","import Observable from 'zen-observable-ts';\nimport { invariant, InvariantError } from 'ts-invariant';\n\nimport {\n  GraphQLRequest,\n  NextLink,\n  Operation,\n  RequestHandler,\n  FetchResult,\n} from './types';\n\nimport {\n  validateOperation,\n  isTerminating,\n  LinkError,\n  transformOperation,\n  createOperation,\n} from './linkUtils';\n\nfunction passthrough(op, forward) {\n  return forward ? forward(op) : Observable.of();\n}\n\nfunction toLink(handler: RequestHandler | ApolloLink) {\n  return typeof handler === 'function' ? new ApolloLink(handler) : handler;\n}\n\nexport function empty(): ApolloLink {\n  return new ApolloLink(() => Observable.of());\n}\n\nexport function from(links: ApolloLink[]): ApolloLink {\n  if (links.length === 0) return empty();\n  return links.map(toLink).reduce((x, y) => x.concat(y));\n}\n\nexport function split(\n  test: (op: Operation) => boolean,\n  left: ApolloLink | RequestHandler,\n  right?: ApolloLink | RequestHandler,\n): ApolloLink {\n  const leftLink = toLink(left);\n  const rightLink = toLink(right || new ApolloLink(passthrough));\n\n  if (isTerminating(leftLink) && isTerminating(rightLink)) {\n    return new ApolloLink(operation => {\n      return test(operation)\n        ? leftLink.request(operation) || Observable.of()\n        : rightLink.request(operation) || Observable.of();\n    });\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return test(operation)\n        ? leftLink.request(operation, forward) || Observable.of()\n        : rightLink.request(operation, forward) || Observable.of();\n    });\n  }\n}\n\n// join two Links together\nexport const concat = (\n  first: ApolloLink | RequestHandler,\n  second: ApolloLink | RequestHandler,\n) => {\n  const firstLink = toLink(first);\n  if (isTerminating(firstLink)) {\n    invariant.warn(\n      new LinkError(\n        `You are calling concat on a terminating link, which will have no effect`,\n        firstLink,\n      ),\n    );\n    return firstLink;\n  }\n  const nextLink = toLink(second);\n\n  if (isTerminating(nextLink)) {\n    return new ApolloLink(\n      operation =>\n        firstLink.request(\n          operation,\n          op => nextLink.request(op) || Observable.of(),\n        ) || Observable.of(),\n    );\n  } else {\n    return new ApolloLink((operation, forward) => {\n      return (\n        firstLink.request(operation, op => {\n          return nextLink.request(op, forward) || Observable.of();\n        }) || Observable.of()\n      );\n    });\n  }\n};\n\nexport class ApolloLink {\n  public static empty = empty;\n  public static from = from;\n  public static split = split;\n  public static execute = execute;\n\n  constructor(request?: RequestHandler) {\n    if (request) this.request = request;\n  }\n\n  public split(\n    test: (op: Operation) => boolean,\n    left: ApolloLink | RequestHandler,\n    right?: ApolloLink | RequestHandler,\n  ): ApolloLink {\n    return this.concat(split(test, left, right || new ApolloLink(passthrough)));\n  }\n\n  public concat(next: ApolloLink | RequestHandler): ApolloLink {\n    return concat(this, next);\n  }\n\n  public request(\n    operation: Operation,\n    forward?: NextLink,\n  ): Observable<FetchResult> | null {\n    throw new InvariantError('request is not implemented');\n  }\n}\n\nexport function execute(\n  link: ApolloLink,\n  operation: GraphQLRequest,\n): Observable<FetchResult> {\n  return (\n    link.request(\n      createOperation(\n        operation.context,\n        transformOperation(validateOperation(operation)),\n      ),\n    ) || Observable.of()\n  );\n}\n"]},"metadata":{},"sourceType":"module"}